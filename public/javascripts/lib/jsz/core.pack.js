// DO NOT EDIT THIS FILE! THIS FILE WILL BE GENERATED AN OVERWRITTEN.
// concat:
// lib.jsz.config
// lib.jsz.core.script
// lib.jsz.core.config
// lib.jsz.core.main
// lib.jsz.core.Array
// lib.jsz.core.String
// lib.jsz.core.Date
// lib.jsz.core.Function
// lib.jsz.core.JSON
// lib.jsz.core.Namespace
// lib.jsz.core.jsz
// lib.jsz.core.Object
// lib.jsz.core.HTMLElement
// lib.jsz.core.HTMLElementsList
// lib.jsz.core.dollar
// lib.jsz.core.dom
// lib.jsz.core.Error
// lib.jsz.core.Listener
// lib.jsz.core.time
// lib.jsz.core


jsz = {
  script: {base:'/assets/javascripts'}
};

/**
 * script-loader
 */
(function() {
  'use strict';

  function isEqual(valueA) {
    var fun;
    if (typeof valueA.equal === 'function') {
      fun = function (valueB) {
        return valueA.equal(valueB);
      };
    }
    else {
      fun = function (valueB) {
        return valueA === valueB;
      };
    }

    return fun;
  }

  function isTrue(bool) {
    return bool === true;
  }

  /**
   * Adds a new script tag to the head of the site.
   */
  window.script = function (conf, fun) {
    conf.fun = fun === undefined ? function(){} : fun;
    conf.evaluated = false;
    conf.loaded = true;

    if (conf.require === undefined) {
      conf.require = [];
    }

    if (conf.name === undefined) {
      conf.name = uniqueId('SCRIPT');
    }

    script.map[conf.name] = conf;

    // TODO: simplify
    script._addDefaultRequirements(conf.name);
    script._defaultRequirement(conf.name);

    delete conf.name;

    if (conf.base !== undefined) {
      this._setBase(conf.base);
    }

    script._evalAll();

  };

  script.map = {};

  script.SLASH = '/';
  script.PERIOD = '.';
  script.PREFIX_JS = '.js';

  script._loadedScriptName = null;
  script._defaultRequirements = [];
  script._base = null;
  script._counter = 0;
  script._srcToNameRegExp = new RegExp('^http.*//[^/]*.(.*).js$');

  script._preloaded = [];



  /**
   * @todo refactoring
   */
  script.init = function (config) {
    if (config.base !== undefined) {
      this._setBase(config.base);
    }

    script._preloaded = (function() {
      var scriptElements = document.getElementsByTagName('script'),
        n = scriptElements.length, i = 0, preloaded = [];

      for (i; i < n; i++) {
        var src = scriptElements.item(i).src;
        if (src !== '') {
          var name = script._srcToNameRegExp.exec(src);
          if (name !== null) {
            preloaded.push(name[1]
              .replace( new RegExp(script.SLASH,'g'), script.PERIOD)
              .substr(script._base.length - 1)
            );
          }
        }
      }

      return preloaded;
    }());

    if (config.preloaded !== undefined) {
      script._preloaded = script._preloaded.concat(config.preloaded);
    }

    script._preloaded.forEach(function(preload) {
      if (script.map[preload] === undefined) {
        script.map[preload] = {
          default: false,
          loaded: true,
          evaluated: true,
          preloaded: true
        };
      }
    });
  };

  script._setBase = function(base) {
    script._base = script.SLASH +
      (/\/*(.*[^\/])\/*/).exec(base)[1] + script.SLASH;
  };

  script.load = function (scriptName) {
    if (script._base === null) {
      throw new Error('Script-loader not initialized! base = null');
    }

    var scriptTag = document.createElement('script');

    scriptTag.setAttribute('src', script._src(scriptName));
    scriptTag.setAttribute('type', 'text/javascript');
    scriptTag.setAttribute('async', 'true');

    document.head.appendChild(scriptTag);

    var conf = {
      loaded: false,
      evaluated: false,
      preloaded: false
    };
    script.map[scriptName] = conf;
    return conf;
  };

  script._src = function (scriptName) {
    if (/^[\w\.]*$/.test(scriptName)) {
      return script._base +
        scriptName.replace(/\./g, script.SLASH) +
        script.PREFIX_JS;
    }
    else {
      throw new Error('Wrong format! script-name = ' + scriptName);
    }
  };

  script._defaultRequirement = function (scriptName) {
    var scriptObject = script.map[scriptName];

    if (scriptObject.default === undefined) {
      scriptObject.default = script._isDefault(scriptName);
    }
    else if (scriptObject.default === true) {
      script._defaultRequirements.push(scriptName);
    }
  };

  script._addDefaultRequirements = function (scriptName) {
    var scriptObject = script.map[scriptName];

    this._defaultRequirements.forEach(function (requirement) {
      var requirementObject = script.map[requirement];
      if (!requirementObject.require.some(isEqual(scriptName))) {
        scriptObject.require.push(requirement);
      }
    });
  };

  script._evalAll = function () {
    script._evalStack = [];
    Object.keys(script.map).forEach(script._eval);
  };

  script._eval = function (scriptName) {
    var evaluated = false;

    // start with the evaluation when script._base is set
    if (script._base !== null) {
      if (script._evalStack.some(isEqual(scriptName))) {
        throw new Error('Cycle reference in script-loader! ' +
          script._evalStack.join(' > ') + ' > ' + scriptName);
      }
      else {
        script._evalStack.push(scriptName);
      }

      var scriptObject = script.map[scriptName];

      if (scriptObject === undefined) {
        // The script has to be loaded
        scriptObject = script.load(scriptName);
      }
      else if (scriptObject.loaded && !scriptObject.evaluated) {
        var evaluate = false;
        if (scriptObject.require === undefined) {
          evaluate = true;
        }
        else {
          evaluate = scriptObject.require.map(script._eval).every(isTrue);
        }

        if (evaluate) {
          if (scriptObject.fun !== undefined) {
            scriptObject.fun.apply(window);
          }
          scriptObject.evaluated = true;
          delete scriptObject.fun;
        }
      }

      script._evalStack.pop();
      evaluated = scriptObject.evaluated;
    }

    return evaluated;
  };

  script._isDefault = function (scriptName) {
    var isDefault = false,
      defaultRequirement,
      n = script._defaultRequirements.length,
      i = 0;

    for (i; i < n; i++) {
      defaultRequirement = script._defaultRequirements[i];
      if (scriptName === defaultRequirement) {
        isDefault = true;
        break;
      }
    }

    return isDefault;
  };

})();

(function() {
  'use strict';

  // A workaround for the safari browser.
  if (console !== undefined) {
    // console.clear();
  }

  // cehck config and set default
  var config;
  if (window.jsz === undefined) {
    config = {};
  }
  else {
    config = window.jsz;
    delete window.jsz;
  }

  /**
   * A namespace for jsz meta-data and configuration.
   */
  window._jsz_ = {
    classes: {},
    version: '0.0.1',
    uniqueId: 0,
    sealObjects: true,
    config: {}
  };

  // ---------------------------------------------------------------------------
  // configuration

  // log
  if (config.log === undefined) {
    _jsz_.config.log = {};
  }
  else {
    _jsz_.config.log = config.log;
  }

  // script
  if (config.script === undefined) {
    _jsz_.config.script = {};
  }
  else {
    _jsz_.config.script = config.script;
    _jsz_.config.script.preloaded = [
      'lib.jsz.config',
      'lib.jsz.core.script',
      'lib.jsz.core.config'
    ];

    script.init(_jsz_.config.script);
  }

})();

/**
 * jsz init
 *
 */
script({
  name: 'lib.jsz.core.main'
}, function () {
  'use strict';

  // Workaround for the safari browser.
  if (console !== undefined) {
    console.clear();
  }

  /**
   * A namespace for jsz meta-data and configuration.
   */
  window._jsz_ = {
    classes: {},
    version: '0.0.1',
    uniqueId: 0,
    sealObjects: true,
    config: {}
  };

  // === jsz-Configuration =====================================================
  // If jsz defined then it holds some configurations for jsz. This var will be
  // overwritten later.
  if (window.jsz !== undefined) {
    if (jsz.log !== undefined) {
      _jsz_.config.log = jsz.log;
    }

    if (jsz.script !== undefined) {
      _jsz_.config.script = jsz.script;
    }

    delete window.jsz;
  }

  // set configuration defaults
  if (_jsz_.log === undefined) {
    _jsz_.log = {};
  }
  if (_jsz_.log.type === undefined) {
    _jsz_.log.type = 'console';
  }

  if (_jsz_.config.script !== undefined) {
    script.init(_jsz_.config.script);
  }


  // ===========================================================================
  // some global constants
  window.JSZ = {
    EMPTY_STRING: '',
    DOT: '.',
    BLANK: ' ',
    SLASH: '/',
    NEW_LINE: '\n',
    PREFIX: {
      JS: '.js'
    },
    META: '_jsz_'
  };

  // ===========================================================================
  // some global functions

  /**
   * The function uniqueId delivers site unique id.
   * @param {String} [prefix]
   * @returns {String}
   */
  window.uniqueId = function (prefix) {
    var id = ++_jsz_.uniqueId;
    return prefix === undefined ? 'ID:' + id : prefix + ':ID:' + id;
  };

  /**
   * This functions joins an scope with a function. In most cases this will be
   * an object and one of his methods.
   */
  window.unite = function (fun, scope) {
    var uniteFun;

    if (fun === undefined) {
      fun = noop;
    }

    if (fun.isUnited) {
      uniteFun = fun;
    }
    else {
      if (scope === undefined) {
        scope = window;
      }

      // The function which the original function and the scope unite.
      uniteFun = function () {
        // This will be executed when the unite is called.
        var args = arguments;
        if (arguments[0] && jsz.isArguments(arguments[0])) {
          args = arguments[0];
        }
        return fun.apply(scope, args);
      };

      uniteFun.isUnited = true;

      uniteFun = Object.freeze(uniteFun);
    }

    return uniteFun;
  };

  /**
   * A convenience function for Function.apply.
   * @param {Fucntion} fun
   * @param {Object} [scope]
   * @param {Array} [args]
   * @returns {*}
   */
  window.apply = function (fun, scope, args) {
    if ( arguments.length === 2)  {
      if (Array.isArray(scope)) {
        args = scope;
        scope = window;
      }
    }
    else {
      if (scope === undefined) {
        scope = window;
      }
    }

    return fun.apply(scope, args);
  };

  /**
   * No operation. This functions is used for do nothing.
   */
  window.noop = function () {
  };

  /**
   * A convenience function for Array.every and Array.some.
   * @param {boolean} bool
   * @returns {boolean}
   */
  window.isTrue = function (bool) {
    return bool === true;
  };

  /**
   * A convenience function for Array.every and Array.some.
   * @param {boolean} bool
   * @returns {boolean}
   */
  window.isFalse = function (bool) {
    return bool === false;
  };

  /**
   * A convenience function for Array.every and Array.some.
   * @param valueA
   * @returns {function}
   */
  window.isEqual = function (valueA) {
    var fun;
    if (typeof valueA.equal === 'function') {
      fun = function (valueB) {
        return valueA.equal(valueB);
      };
    }
    else {
      fun = function (valueB) {
        return valueA === valueB;
      };
    }

    return fun;
  };

  /**
   * A convenience function for Array.every and Array.some.
   * @param valueA
   * @returns {function}
   */
  window.isNotEqual = function (valueA) {
    var fun;
    if (typeof valueA.equal === 'function') {
      fun = function (valueB) {
        return !valueA.equal(valueB);
      };
    }
    else {
      fun = function (valueB) {
        return valueA !== valueB;
      };
    }

    return fun;
  };

  /**
   * A toString method for jsz classes.
   * @returns {string}
   */
  window._jsz_.classToString = function () {
    var path = this._jsz_.namespace._jsz_.path;
    var name = this._jsz_.className;
    return '[' + path + '.' + name + ' Class]';
  };
});

/**
 * The script Array.js contains some extensions to the built-in Array.
 *
 * @author Marcus Kruse
 * @version 0.1.0
 */
script({name:'lib.jsz.core.Array'}, function () {
  'use strict';

  if (Array.from === undefined) {
    /**
     * The Array.from() method creates a new Array instance from an array-like
     * or iterable object.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/
     *   Reference/Global_Objects/Array/from|MDN: Array.from}
     *
     * @param {*} arrayLike An array-like or iterable object to convert to an
     *   array.
     * @param {Function} [mapCallback=noop] Map function to call on every
     *   element of the array.
     * @param {Object} [scope=window] Value to use as scope when executing
     *   mapCallback.
     * ------------------------------------------------------------------------
     * @compatibility
     * @timestamp 2015-07-31
     * @reference {@link https://developer.mozilla.org/en-US/docs/Web/
     *   JavaScript/Reference/Global_Objects/Array/from#Browser_compatibility|
     *   Array.from - Browser compatibility}
     * @ES 6
     * @FF 32
     * @CH 45, mobile not supported
     * @IE not supported
     * @OP not supported
     * @SF not supported
     */
    Array.from = function (arrayLike, mapCallback, scope) {
      if (arrayLike === undefined || arrayLike === null) {
        throw new TypeError('Array.from requires an array-like object' +
        ' - not null or undefined.');
      }

      var length = arrayLike.length;

      if (!(jsz.isInt(length) && length >= 0)) {
        throw new TypeError('Array.from requires an array-like object. ' +
        'Can not find length of array-like not found.');
      }

      // set a flag for the mapping
      var mapFlag = mapCallback !== undefined,
        newArray = new Array(length),
        index = 0,
        value;


      if (mapFlag) {
        scope = jsz.default(scope, window);
      }

      while (index < length) {
        if (mapFlag) {
          value = mapCallback.apply(scope, [arrayLike[index]]);
        }
        else {
          value = arrayLike[index];
        }

        newArray[index] = value;

        index++;
      }

      return newArray;
    };
  }

  if (Array.find === undefined) {
    /**
     * This method returns the first item of the array that match the specified
     * predicate.
     *
     * @param {Function} predicate
     * @param {Object} scope
     * @returns {*}
     * ------------------------------------------------------------------------
     * @compatibility
     * @timestamp 2015-08-04
     * @reference {@link https://developer.mozilla.org/en-US/docs/Web/
     *   JavaScript/Reference/Global_Objects/Array/find#Browser_compatibility|
     *   Array.find - Browser compatibility}
     * @ES 6
     * @FF 25
     * @CH not supported
     * @IE not supported
     * @OP not supported
     * @SF not supported
     */
    Object.defineProperty(Array.prototype, 'find', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: function (predicate, scope) {
        var callback = unite(predicate, scope);

        var list = this,
          index = 0,
          length = list.length,
          item;

        while (index < length && item === undefined) {
          if (callback(list[index]) === true) {
            item = list[index];
          }
          index++;
        }

        return item;
      }
    });
  }

  /**
   * Array.isEmpty returns true if an array contains no values.
   * @returns {boolean}
   */
  Object.defineProperty( Array.prototype, 'isEmpty', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function () {
      return this.length === 0;
    }
  });

  /**
   * Array.isNotEmpty returns true if an array contains any value.
   * @returns {boolean}
   */
  Object.defineProperty( Array.prototype, 'isNotEmpty', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function () {
      return !this.isEmpty();
    }
  });

  /**
   * The mehotd toArguments returns an arguments object of this list.
   * @returns {Arguments}
   */
  Object.defineProperty( Array.prototype, 'toArguments', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function () {
      return jsz.listToArguments(this);
    }
  });

  /**
   * The contains method returns true if the given value is in the array. If the
   * method get a callback then they returns true if the callback function
   * returns true for any array element.
   * @param {*} value
   * @param {arrayContainsCallback} [callback]
   * @param {Object} [scope]
   * @returns {boolean}
   *
   * @callback arrayContainsCallback
   * @param {*} value The value that was passed to contains.
   * @param {*} currentValue The current element being processed in the array.
   * @param {*} index The index of the current element being processed in the
   *   array.
   * @param {Array} array The array contains was called upon.
   * @returns {boolean}
   */
  Object.defineProperty( Array.prototype, 'contains', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function (value, callback, scope) {
      // Value must be a type that can be handled by ===
      if (callback === undefined) {
        return this.some(isEqual(value));
      }
      else {
        return this.some(function (currentValue, index, array) {
          return apply(callback, scope, [value, currentValue, index, array]);
        });
      }
    }
  });

  /**
   * The method flatten returns a new array that is a one dimensional array of
   * it self.
   *
   * @example
   * [1,2,[3,4],5].flatten(); //=> [1,2,3,4,5]
   * [1,[2,[3,[4,5]]]].flatten(); //=> [1,2,3,4,5]
   *
   * @returns {Array}
   */
  Object.defineProperty( Array.prototype, 'flatten', {
    enumerable: false,
    configurable: false,
    writable: false,
    value: function() {
      var array = [];

      this.forEach(function(item) {
        if (Array.isArray(item)) {
          array = array.concat(item.flatten());
        } else {
          array.push(item);
        }
      });

      return array;
    }
  });

});

/**
 * The script String.js contains some extensions to the built-in String.
 *
 * @author Marcus Kruse
 * @version 0.1.0
 */
script({name: 'lib.jsz.core.String'}, function () {
  'use strict';

  /**
   * The method String.toCamelCase returns this string in a camel case style.
   * @example
   * 'snake-case'.toCamelCase(); // returns 'snakeCase'
   * 'kebab_case'.toCamelCase(); // returns 'kebabCase'
   * 'kebab_snake-case'.toCamelCase(); // returns 'kebabSnakeCase'
   *
   * @returns {string}
   */
  String.prototype.toCamelCase = function () {
    var splits = this.split(/[-|_]/);
    var newString = splits.shift().toLowerCase();

    splits.forEach( function(string) {
      newString = newString + string.substr(0, 1).toUpperCase() +
        string.substr(1).toLowerCase();
    });

    return newString;
  };

  /**
   * Compares this string with the given string and ignoring the case.
   *
   * @param {String} str
   * @returns {boolean}
   */
  String.prototype.equalsIgnoreCase = function (str) {
    var result = false;

    if (!(str === undefined || str === null)) {
      var regex = new RegExp('^' + str + '$', 'i');
      result = regex.test(this);
    }

    return result;
  };

  if (String.prototype.startsWith === undefined) {
    /**
     * The startsWith method determines whether a string begins with the
     * characters of another string, returning true or false as appropriate.
     *
     * @param {String} searchString
     * @param {Integer} [position]
     * @returns {boolean}
     * ------------------------------------------------------------------------
     * @compatibility
     * @timestamp 2015-08-03
     * @reference {@link https://developer.mozilla.org/en-US/docs/Web/
     *   JavaScript/Reference/Global_Objects/String/startsWith#
     *   Browser_compatibility}
     * @ES 6
     * @FF 17
     * @CH 41, 36
     * @IE not supported
     * @OP not supported
     * @SF not supported
     */
    String.prototype.startsWith = function(searchString, position) {
      position = jsz.default(position, 0  );
      return this.indexOf(searchString, position) === position;
    };
  }

  if (String.repeat === undefined) {
    String.prototype.repeat = function(times) {
      var string = this.toString(),
        result = JSZ.EMPTY_STRING,
        i = 0;

      if (isNaN(times)) {
        throw new TypeError('Repeat times must be a number.');
      }

      if (times < 0) {
        throw new Error('Repeat times must non-negative!');
      }

      while (i < times) {
        result = result + string;
        i++;
      }

      return result;
    };
  }
});

script({name: 'lib.jsz.core.Date'}, function () {
  'use strict';

  /**
   * Milliseconds in one second (1000) (ISO).
   * @constant
   * @type {Integer}
   */
  Date.MILLIS_PER_SECOND = 1000;

  Date.prototype.equals = function(date) {
    return this.getTime() === date.getTime();
  };

});


/**
 * This script adds some methods to the Function. This methods are used in the
 * class declaration of jsz.
 *
 * @author   Marcus Kruse
 * @version  0.1.0
 */
script({name: 'lib.jsz.core.Function'}, function () {
  'use strict';

  /**
   * The method def adds members and methods to a class.
   *
   * @param {Object} object
   * @returns {Function} Returns the class itself.
   */
  Function.prototype.def = function (object) {
    this._jsz_.properties = {};
    var key, enumerable, writeable, isFunction, isNoop;
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        // Set new property to class.

        // The new property is a function.
        isFunction = object[key] !== null &&
          (typeof object[key] === 'function');

        isNoop = isFunction && object[key] === noop;

        if ( !isFunction || isNoop) {
          // The _jsz_.properties will be defined on every new instance.
          this._jsz_.properties[key] =
            Object.createDescriptor(key, object[key]);
        }
        else {
          Object.addProperty( this.prototype, key, object[key]);
        }

      }
    }

    return this;
  };

  /**
   * The method static adds static members and methods to a class.
   *
   * @param {Object} object
   * @returns {Function} Returns the class itself.
   */
  Function.prototype.static = function (object) {
    var key;

    for (key in object) {
      if (object.hasOwnProperty(key)) {
        this[key] = object[key];
      }
    }

    return this;
  };

});

/**
 * The script JSON.js contains some functions to build reviver.
 *
 * @author Marcus Kruse
 * @version 0.1.0
 */
script({name: 'lib.jsz.core.JSON'}, function () {
  'use strict';

  /**
   * A copy of the original parser.
   *
   * @param {String} jsonString
   * @param {Function} [reviver]
   * @return {Object}
   * @static
   */
  JSON._origignalParse = JSON.parse;

  /**
   * The function parse works like the built-in parse but takes the JSON.reviver
   * as reviver if it is set and the reviver is not set. The JSON.reviver is a
   * default for the reviver.
   *
   * @overwrite
   * @param {String} jsonString
   * @param {Function} [reviver]
   * @return {Object}
   * @static
   */
  JSON.parse = function(jsonString, reviver) {
    reviver = jsz.default(reviver, JSON.reviver);
    var object;
    if (reviver === undefined || reviver === null) {
      object = JSON._origignalParse(jsonString);
    }
    else {
      object = JSON._origignalParse(jsonString, reviver);
    }

    return object;
  };

  /**
   * The function reviverRegExpValue generates a reviver function for the parse
   * function. If the RegExp test evaluate to true for a value from the
   * jsonString this value will be send to format function.
   *
   * @param {RegExp} regExp
   * @param {Function} format
   * @returns {Function}
   */
  JSON.reviverRegExpValue = function (regExp, format) {
    return function (key, value) {
      return regExp.test(value) ? format(value) : value;
    };
  };

  /**
   * The function reviverZuluTime formats values of type yyyy-MM-ddTHH:mm:ssZ to
   * a date.
   * The used RegExp: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/
   *
   * @type {Function}
   */
  JSON.reviverZuluTime = JSON.reviverRegExpValue(
    /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/, function (zulu) {
      return new Date(zulu);
    });

});

/**
 * The Namespace ...
 * TODO: Documentation!
 */

script({
  name: 'lib.jsz.core.Namespace',
  require: [
    'lib.jsz.core.main',
    'lib.jsz.core.Function'
  ]
}, function () {
  'use strict';

  /**
   * This function generate a jsz-namespace from the param namespace.
   * example:
   * {code}
   * var x = namespace('foo.bar');
   * alert(foo.toString());        // [foo:_jsz_.Namespace]
   * alert(foo.bar.toString());    // [foo.bar:_jsz_.Namespace]
   * {code}
   * Namespaces are just js-objects.
   *
   * @param namespacePath:String
   * @return namespace:Namespace
   */
  window.namespace = function (namespacePath) {

    if (namespacePath === undefined) {
      throw new Error('No path for namespace given.');
    }

    var pathParts = namespacePath.split(JSZ.DOT),
      currentNamespace = window, // The root of all namespaces.
      path = JSZ.EMPTY_STRING;

    // Walk along the given path.
    pathParts.forEach(function (pathPart) {
      path += path === JSZ.EMPTY_STRING ? pathPart : JSZ.DOT + pathPart;

      if (!currentNamespace[pathPart]) {
        currentNamespace[pathPart] = new _jsz_.Namespace(path);
      }

      currentNamespace = currentNamespace[pathPart];
    });

    return currentNamespace;
  };

  window.module = function (name) {
    var ns = namespace(name);
    ns._jsz_.module = name;
    return ns;
  };

// The namespace object.
  _jsz_.Namespace = function (path) {
    this._jsz_ = {path: path};
  };

  /**
   * toString
   */
  _jsz_.Namespace.prototype.toString = function () {
    return '[Namespace:' + this._jsz_.path + ']';
  };

  /**
   * Creates a module
   *
   * @param name
   * @returns module
   */
  _jsz_.Namespace.prototype.module = function (name) {
    if (this[name] !== undefined) {
      console.trace();
      throw new Error(name + ' ist not a valid name for a module!');
    }

    var module = namespace(this._jsz_.path + JSZ.DOT + name);
    module._jsz_.module = name;

    return module;
  };


  /**
   *  def to define things for a module
   *  TODO: Documentation!
   */
  _jsz_.Namespace.prototype.def = function (object) {
    if (this._jsz_.module === undefined) {
      throw new Error('Not a module!');
    }

    var key,
      moduleInitFunction = null,
      moduleName = this._jsz_.module;

    for (key in object) {
      if (object.hasOwnProperty(key)) {
        if (key === moduleName && typeof object[key] === 'function') {
          moduleInitFunction = object[key];
        }
        else {
          this[key] = object[key];
        }
      }
    }

    // initialize module
    if (moduleInitFunction !== null) {
      moduleInitFunction.apply(this);
    }

    return this;
  };

  /**
   * class
   * TODO: Documentation
   */
  _jsz_.Namespace.prototype.class = function (className, extend) {

    var namespace = this,
      inners,
      firms,
      fullClassName = namespace._jsz_.path + '.' + className;


    // Check arguments count.
    if (!(arguments.length === 1 || arguments.length === 2)) {
      throw new Error('Wrong count of parameters for _jsz_.Namespace.Class!');
    }

    // Generate the new class.
    var newClass = _jsz_.Namespace.getNewClass(namespace, className, extend);

    _jsz_.classes[fullClassName] = newClass;

    // toString for the class
    newClass.toString = _jsz_.classToString;

    // If the class will be extended
    if (extend === undefined) {
      // Every base class extends jsz.Object.
      newClass.prototype = Object.create(jsz.Object.prototype);
    }
    else {
      newClass.prototype = Object.create(extend.prototype);

      // add firms to the class
      // TODO: implement firms
      /*
       firms = extend._jsz_.firms;
       if (firms !== undefined) {
       var key;
       for (key in firms) {
       if (firms.hasOwnProperty(key)) {
       newClass[key] = firms[key];
       }
       }
       }
       */

      // TODO: implements inners
      /*
       inners = extend._jsz_.inners;
       */
    }

    // Set meta-infos for the new class
    Object.defineProperty(newClass, JSZ.META, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: {
        className: className,
        namespace: namespace,
        extend: extend,
        inners: inners,
        firms: firms
      }
    });

    // Add new class to the namespace.
    this[className] = newClass;

    return newClass;
  };

  /**
   * class
   * TODO: Documentation
   */
  _jsz_.Namespace.getNewClass = function (namespace, className, extension) {
    // Returns the function that will be our class and constructor.
    return function () {
      var thisClass = namespace[className];
      var metaClass = thisClass[JSZ.META];
      var newObject = null;

      // Create a new object.
      newObject = Object.create(thisClass.prototype, metaClass.properties);

      // Set meta-info for the new object
      Object.defineProperty(newObject, JSZ.META, {
        enumerable: false,
        configurable: false,
        writable: true,
        value: {
          className: className,
          namespace: namespace,
          extend: extension || false,
          super: 0 // auxiliary variable for the constructor chain
        }
      });

      // handle inners
      /* TODO: handle inners
       if ( metaClass.inners) {
       jsz.util.inners( this, metaClass.inners);
       }
       */

      // call the constructor
      if (newObject[className]) {
        newObject[className].apply(newObject, arguments);
      }

      delete newObject[JSZ.META].super;

      if (_jsz_.sealObjects) {
        Object.seal(newObject);
      }

      return newObject;

    };
  };

  /**
   * Creates a simple Class
   * TODO: Documentation!
   */
  _jsz_.Namespace.prototype.proto = function () {
    var name, base, def;

    name = arguments[0];

    if (arguments.length === 2) {
      base = null;
      def = arguments[1];
    }
    else {
      base = arguments[1];
      def = arguments[2];
    }

    var newClass = typeof def[name] === 'undefined' ? function () {
    } : def[name];


    var key;
    for (key in def) {
      if (def.hasOwnProperty(key) && key !== name) {
        newClass.prototype[key] = def[key];
      }
    }

    if (base !== null) {
      newClass.prototype = Object.create(base.prototype);
    }

    this[name] = newClass;
  };

  namespace('jsz');

});

/**
 * The script jsz.js contains core functions.
 *
 * @author Marcus Kruse
 * @version 0.1.0
 */
script({
  name: 'lib.jsz.core.jsz',
  require: ['lib.jsz.core.Namespace']
}, function () {
  'use strict';

  module('jsz').def({

    ARGUMENTS_TO_STRING: '[object Arguments]',

    /**
     * The jsz.default function returns a default value if the value is
     * undefined.
     *
     * @param {*} value
     * @param {*} defaultValue
     * @returns {*}
     */
    default: function(value, defaultValue) {
      return value === undefined ? defaultValue : value;
    },

    /**
     * The jsz.defaults function returns a copy of object extended by missing
     * key value pairs from the default object. If the object is undefined then
     * the default object will be returned.
     *
     * @example
     * var hash = {a:1};
     * jsz.defaults(hash, {a:9,b:2}); // returns {a:1,b:2}
     *
     * @example
     * var hash = {a:{x:1,y:2},b:{x:1}};
     * jsz.defaults(hash, {a:{x:0,y:0}, b:{x:0, y:0}, c:{x:0, y:0}});
     * // returns {a:{x:1,y:2}, b:{x:1, y:0}, c:{x:0, y:0}}
     *
     * @param object
     * @param defaultObject
     * @returns {{}}
     */
    defaults: function(object, defaultObject) {
      // The original object will be cloned and the keys of the default objects
      // will be iterate to find missing key value pairs in the original object.
      var newObject = Object.clone(object);

      Object.keys(defaultObject).forEach(function(key) {
        if (object[key] === undefined) {
          // Take the value form the default object
          newObject[key] = defaultObject[key];
        }
        else {
          if (jsz.isPlainObject(defaultObject[key])) {
            // If the value of the default object is a plain object then go
            // deeper.
            newObject[key] = jsz.defaults(object[key], defaultObject[key]);
          }
          else {
            // Take the value from the original object.
            newObject[key] = object[key];
          }
        }
      });

      return newObject;
    },

    /**
     * @todo documentation
     * @experimental
     * @returns {Object}
     */
    args: function() {
      var argsDef = Array.from(arguments);
      var argsList = Array.from(argsDef.shift()),
        args = {};

      if (argsDef.length === argsList.length) {
        argsDef.forEach( function(argDef) {
          args[argDef.name] = argsList.shift();
        });
      }
      else {
        argsDef.forEach( function(argDef) {
          var name = argDef.name;
          args[name] = undefined;

          if ( argDef.type === String) {
            if (jsz.isString(argsList[0])) {
              args[name] = argsList.shift();
            }
          }
          else if (argDef.type === Object) {
            if (jsz.isObject(argsList[0])) {
              args[name] = argsList.shift();
            }
          }
          else {
            if (argsList[0] instanceof argDef.type) {
              args[name] = argsList.shift();
            }
          }

          if (args[name] === undefined && argDef.optional !== true) {
            throw new Error('Missing argument ' + name + '!');
          }

          if (argDef.default !== undefined && args[name] === undefined) {
            args[name] = argDef.default;
          }

        });
      }

      return args;
    },

    /**
     * This function converts a list in a arguments object.
     * @param list
     */
    listToArguments: function(list) {
      return jsz._listToArguments.apply(this, list);
    },

    /**
     * A helper for jsz.listToArguments.
     * @returns {Arguments}
     * @private
     */
    _listToArguments: function() {
      return arguments;
    },

    // =========================================================================
    // All isType functions are just convenience functions. These functions
    // save a typeof or instanceof.

    /**
     * The jsz.isError function returns true if an object is an Error or an
     * jsz.Error object, false if it is not.
     *
     * @param {*} obj
     * @returns {boolean}
     */
    isError: function (obj) {
      return obj instanceof Error || obj instanceof jsz.Error;
    },

    /**
     * The jsz.isFunction function returns true if an object is a function,
     * false if it is not.
     *
     * @param {*} obj
     * @returns {boolean}
     */
    isFunction: function (obj) {
      return typeof obj === 'function';
    },

    /**
     * The jsz.isRegExp function returns true if an object is a regular
     * expression object,
     * false if it is not.
     *
     * @param {*} obj
     * @returns {boolean}
     */
    isRegExp: function (obj) {
      return obj instanceof RegExp;
    },

    /**
     * The jsz.isArguments function returns true if an object is an arguments
     * object, false if it is not.
     *
     * @param {*} obj
     * @returns {boolean}
     */
    isArguments: function (obj) {
      return obj !== undefined && (obj !== null) &&
        Object.prototype.toString.call(obj) === jsz.ARGUMENTS_TO_STRING;
    },

    /**
     * The jsz.isArray function returns true if an object is an array, false
     * if it is not.
     *
     * @param {*} obj
     * @return {boolean}
     */
    isArray: Array.isArray, // just an alias

    /**
     * The jsz.isObject function returns true if an object is an object,
     * false if it is not.
     *
     * @param {*} obj
     * @return {boolean}
     */
    isObject: function (obj) {
      return obj !== undefined && typeof obj === 'object' &&
        !Array.isArray(obj);
    },

    /**
     * The jsz.isObject function returns true if an object is a plain object,
     * false if it is not.
     *
     * @param {*} obj
     * @return {boolean}
     */
    isPlainObject: function(obj) {
      var is = jsz.isObject(obj);

      if (obj === window || jsz.isArguments(obj)) {
        is = false;
      }

      if ( is &&
        obj.constructor &&
        !obj.hasOwnProperty('constructor') &&
        !obj.constructor.prototype.hasOwnProperty('isPrototypeOf')) {
        is = false;
      }

      if (is) {
        var key;
        for ( key in obj) {
          /* empty */
        }

        is = (key === undefined || obj.hasOwnProperty(key));
      }

      return is;
    },

    /**
     * The jsz.isNumber function returns true if an object is a number,
     * false if it is not.
     *
     * @param {*} obj
     * @return {boolean}
     */
    isNumber: function (obj) {
      return typeof obj === 'number' && isFinite(obj);
    },

    /**
     * The jsz.isBoolean function returns true if an object is a boolean,
     * false if it is not.
     *
     * @param {*} obj
     * @return {boolean}
     */
    isBoolean: function (obj) {
      return typeof obj === 'boolean';
    },

    /**
     * The jsz.isBoolean function returns true if an object is a string,
     * false if it is not.
     *
     * @param {*} obj
     * @return {boolean}
     */
    isString: function (obj) {
      return typeof obj === 'string';
    },

    /**
     * The jsz.isBoolean function returns true if an object is an integer,
     * false if it is not.
     *
     * @param {*} object
     * @return {boolean}
     */
    isInt: function (object) {
      var is = false;
      if (object !== undefined) {
        is = (/^-?\d+$/).test(object.toString());
      }
      return is;
    },

    /**
     * The jsz.isBoolean function returns true if an object is a date,
     * false if it is not.
     *
     * @param {*} obj
     * @return {boolean}
     */
    isDate: function (obj) {
      return obj instanceof Date;
    }

  });

});

// TODO: Documentation

/**
 * This script contains the implementation of jsz.Object, some static
 * functions for the built-in Object and the function object to create simple
 * objects.
 */
script({
  name: 'lib.jsz.core.Object',
  require: ['lib.jsz.core.Namespace']
  // require: []
}, function () {
  'use strict';

  jsz.Object = function () {};

  jsz.Object.prototype.getClass = function () {
    return _jsz_.classes[this.getClassName()];
  };

  jsz.Object.prototype.toString = function () {
    return '[object ' + this.getClassName() + ']';
  };

  jsz.Object.prototype.getClassName = function () {
    return this._jsz_.namespace._jsz_.path + JSZ.DOT + this._jsz_.className;
  };

  jsz.Object.prototype.super = function () {
    var i = 0,
      skip = this._jsz_.super; // skip n constructors

    var extend = this._jsz_.extend;
    for (i; i < skip; i++) {
      // skip constructors
      extend = extend._jsz_.extend;
    }


    if (extend !== undefined) {
      this._jsz_.super++;

      var baseClass = extend;
      var baseClassName = baseClass._jsz_.className;
      var baseConstructor = baseClass.prototype[baseClassName];

      if (baseConstructor) {
        baseConstructor.apply(this, arguments);
      }
      else {
        if (extend) {
          this.super.apply(this, arguments);
        }
      }

      this._jsz_.super--;
    }

  };

  // ===========================================================================
  // Static functions for the built-in Object.

  /**
   * Creates an identical object form the specified object.
   *
   * @note For the moment its works just right for plain objects.
   *
   * @param {*} object
   * @returns {*}
   */
  Object.clone = function (object) {
    if (object === undefined) {
      throw new Error('Can not clone undefined!');
    }

    var newObject = {};

    if (jsz.isPlainObject(object)) {
      Object.keys(object).forEach(function(key) {
        var value = object[key];

        if (jsz.isPlainObject(value)) {
          newObject[key] = Object.clone(value);
        }
        else {
          newObject[key] = value;
        }
      });
    }
    else if (object.clone !== undefined) {
      newObject = object.clone();
    }
    else {
      throw new Error('Can not clone object!');
    }

    return newObject;
  };

  /**
   * Returns true if the given object has no enumerable keys.
   *
   * @param {Object} object
   * @returns {boolean}
   */
  Object.isEmpty = function (object) {
    return Object.keys(object).isEmpty();
  };

  /**
   * The addProperty function is a special form of defineProperty. This function
   * detects the descriptor enumerable and enumerable by the given propName.
   * For propNames starts with _ the enumerable key will be set to false
   * otherwise to true.
   * For propNames with only upper case characters the writable key will be set
   * to false otherwise to true.
   * The keys get and set remain unset.
   * The key configurable will be set to false by default.
   *
   * @param {Object} object
   * @param {String} propName
   * @param {*} value
   */
  Object.addProperty = function(object, propName, value) {
    Object.defineProperty(
      object, propName, Object.createDescriptor(propName, value));
  };

  /**
   * The addProperties function is a special form of defineProperties. The
   * argument props is a key value object wherein the key is the property name
   * and the value is the property value. At this point addProperties works like
   * as addProperty for all properties in props.
   *
   * @param {Object} object
   * @param {Object.<String,*>} props
   */
  Object.addProperties = function(object, props) {
    Object.defineProperties( object, Object.createDescriptors(props));
  };

  /**
   * This function returns a descriptor for defineProperty by the rules that
   * are defined in addProperty.
   *
   * @param propName
   * @param value
   */
  Object.defineProperty(Object, 'createDescriptor', {
    enumerable: false,
    writable: false,
    configurable: false,
    value:    function(propName, value) {
      return {
        // If key starts with '_' then set enumerable to false.
        enumerable: propName.indexOf('_') !== 0,
        // If key indicates a constant then set writeable to false.
        writable: !(/^[A-Z|_]*$/).test(propName),
        // configurable is by default false
        configurable: false,
        value: value
      };
    }
  });

  /**
   * This function returns a descriptors object for defineProperties by the
   * rules that are defined in addProperty.
   *
   * @param propName
   * @param value
   */
  Object.defineProperty(Object, 'createDescriptors', {
    enumerable: false,
    writable: false,
    configurable: false,
    value: function(props) {
      return Object.keys(props).reduce(
        function(descriptors, propName) {
          descriptors[propName] =
            Object.createDescriptor(propName, props[propName]);
          return descriptors;
        }, {});
    }
  });

  // ===========================================================================
  // window.object to create objects on the fly
  /**
   *
   * @param {Function} [init]
   * @param {Object} properties
   * @returns {jsz.Object}
   */
  window.object = function(init, properties) {
    if ( arguments.length === 1) {
      properties = init;
      init = null;
    }

    var object = Object.create(jsz.Object.prototype,
      Object.createDescriptors(properties));

    object.toString = function() {
      return '[object Object]';
    };

    if (init !== null) {
      init.apply(object);
    }

    return object;
  };

});

/**
 * This script holds the jsz.HTMLElement class.
 *
 * @author   Marcus Kruse
 * @version  0.1.0
 */
script({
  name: 'lib.jsz.core.HTMLElement',
  require: [
    'lib.jsz.core.Namespace',
    'lib.jsz.core.jsz'
  ]
}, function () {
  'use strict';

  /**
   * The jsz.HTMLElement class is a wrapper for all html elements.
   */
  namespace('jsz').proto('HTMLElement', {

    /**
     * The constructor to wrap a html element.
     *
     * @param {HTMLElement} element
     */
    HTMLElement: function (element) {
      this._element = jsz.default(element, null);
    },

    /**
     * A constant for the prefix of custom attributes in HTML.
     * @const {String}
     */
    CUSTOM_ATTRIBUTE_PREFIX: 'data-',
    /**
     * A constant for the prefix of custom jsz-attributes in HTML.
     * @const {String}
     */
    CUSTOM_JSZ_PREFIX: 'data-jsz-',

    /**
     * This function calls a given function with the wrapped element as scope.
     * If the jsz.HTMLElement is empty this methods returns null.
     * 
     * @param {Function} fun
     * @param {Array} args
     * @returns {*}
     */
    _apply: function (fun, args) {
      var result = null;
      if (this.isNotEmpty()) {
        result = apply(fun, this._element, args);
      }

      return result;
    },

    /**
     * isEmpty returns true if the wrapped element is null.
     *
     * @returns {boolean}
     */
    isEmpty: function () {
      return this._element === null;
    },

    /**
     * isNotEmpty returns true if the wrapped element is not null.
     *
     * @returns {boolean}
     */
    isNotEmpty: function () {
      return this._element !== null;
    },

    /**
     * The method get returns the wrapped element or null if the jsz.HTMLElement
     * is empty.
     *
     * @returns {HTMLElement|null}
     */
    get: function () {
      return this._element;
    },

    /**
     * The jsz.HTMLElement.append method adds a jsz.HTMLElement to
     * the end of the list of children of this jsz.HTMLElement.
     *
     * @param {jsz.HTMLElement} element
     * @returns {*}
     */
    append: function(element) {
      return this._apply(HTMLElement.prototype.appendChild, [element.get()]);
    },

    /**
     * Adds a new attribute or changes the value of an existing attribute.
     * @example
     * <button id="foo">Hello</button>
     * @example
     * $id('foo').setAttribute('disabled', 'disabled');
     *
     * @param {String} name
     * @param {String} value
     * @returns {*}
     */
    setAttribute: function(name, value) {
      return this._apply(HTMLElement.prototype.setAttribute, [name, value]);
    },

    /**
     * Adds a new custom attribute or changes the value of an existing custom
     * attribute.
     * @example
     * <button id="foo" data-my="world">Hello</button>
     * @example
     * $id('foo').setCustomAttribute('my', 'universe');
     *
     * @param {String} name
     * @param {String} value
     * @returns {*}
     */
    setCustomAttribute: function(name, value) {
      return this._apply(HTMLElement.prototype.setAttribute,
        [this.CUSTOM_ATTRIBUTE_PREFIX + name, value]);
    },

    /**
     * Adds a new jsz-attribute or changes the value of an existing
     * jsz-attribute.
     * @example
     * <button id="foo" data-jsz-my="world">Hello</button>
     * @example
     * $id('foo').setJszAttribute('my', 'universe');
     *
     * @param {String} name
     * @param {String} value
     * @returns {*}
     */
    setJszAttribute: function(name, value) {
      return this._apply(HTMLElement.prototype.setAttribute,
        [this.CUSTOM_JSZ_PREFIX + name, value]);
    },

    /**
     * This method returns the value of a specified attribute.
     *
     * @param {String} name
     * @returns {String|null}
     */
    getAttribute: function(name) {
      var value = this._apply(HTMLElement.prototype.getAttribute, [name]);
      return value === JSZ.EMPTY_STRING ? null : value;
    },

    /**
     * This method returns the value of a specified custom attribute.
     * @example
     * <button id="foo" data-my="world">Hello</button>
     * @example
     * $id('foo').getCustomAttribute('my'); // returns 'world'
     *
     * @param {String} name
     * @returns {String|null}
     */
    getCustomAttribute: function(name) {
      var value = this._apply(HTMLElement.prototype.getAttribute,
        [this.CUSTOM_ATTRIBUTE_PREFIX + name]);
      return value === JSZ.EMPTY_STRING ? null : value;
    },

    /**
     * This method returns the value of a specified jsz-attribute.
     * @example
     * <button id="foo" data-jsz-my="world">Hello</button>
     * @example
     * $id('foo').getJszAttribute('my'); // returns 'world'
     *
     * @param {String} name
     * @returns {String|null}
     */
    getJszAttribute: function(name) {
      var value = this._apply(HTMLElement.prototype.getAttribute,
        [this.CUSTOM_JSZ_PREFIX + name]);
      return value === JSZ.EMPTY_STRING ? null : value;
    },

    /**
     * This methods set several attributes specified by a hash object.
     *
     * @todo documentation and example
     *
     * @param {Object} attributes
     */
    setAttributes: function(attributes) {
      Object.keys(attributes).forEach(function(name) {
        var value = attributes[name];
        if (name.equalsIgnoreCase('style')) {
          this.setStyles(value); // TODO: implement setStyles
        }
        else if (name.equalsIgnoreCase('jsz')) {
          this.setJszAttributes(value);
        }
        else if (name.equalsIgnoreCase('custom')) {
          this.setCustomAttributes(value);
        }
        else {
          if (jsz.isArray(value)) {
            value = value.join(JSZ.BLANK);
          }
          this.setAttribute(name, value);
        }
      }, this);
    },

    setJszAttributes: function(attributes) {
      Object.keys(attributes).forEach(function(name) {
        var value = attributes[name];
        this.setJszAttribute(name, value);
      }, this);
    },

    setCustomAttributes: function(attributes) {
      Object.keys(attributes).forEach(function(name) {
        var value = attributes[name];
        this.setCustomAttribute(name, value);
      }, this);
    },


    html: function(html) {
      if (html === undefined) {
        html = this._element.innerHTML;
      }
      else {
        this._element.innerHTML = html;
      }

      return html;
    },

    getId: function () {
      return this._apply(HTMLElement.prototype.getAttribute, ['id']);
    },

    setStyle: function (style, value) {
      jsz.dom.setStyle(this._element, style, value);
    },

    setStyles: function(object) {
      // TODO: implement setStyles
    },

    hasType: function () {
      return Boolean(
        this._apply(HTMLElement.prototype.hasAttribute, ['type'])
      ).valueOf();
    },

    isType: function (type) {
      return this.hasType() &&
        type.equalsIgnoreCase(this.getType());
    },

    getType: function () {
      this._apply(HTMLElement.prototype.getAttribute, ['type']);
    },

    getCssClasses: function () {
      return this._apply(
        HTMLElement.prototype.getAttribute, ['class']).split(JSZ.BLANK);
    },

    addCssClass: function (cssClass) {
      var cssClasses = this.getCssClasses();
      cssClasses.push(cssClass);
      this._apply(
        HTMLElement.prototype.setAttribute, ['class',
          cssClasses.join(JSZ.BLANK)]
      );
    },

    removeCssClass: function (cssClass) {
      if (arguments.length > 1) {
        this.removeCssClasses(Array.from(arguments));
      }
      else {
        var cssClasses = this.getCssClasses();
        this._apply(
          HTMLElement.prototype.setAttribute, ['class',
            cssClasses.filter(isNotEqual(cssClass)).join(JSZ.BLANK)]
        );
      }
    },

    removeCssClasses: function(cssClasses) {
      cssClasses.forEach( function(cssClass) {
        this.removeCssClass(cssClass);
      }, this);
    },

    toggleCssClass: function (cssClassA, cssClassB) {
      if (jsz.isArray(cssClassA)) {
        cssClassB = cssClassA[1];
        cssClassA = cssClassA[0];
      }

      var cssClasses = this.getCssClasses(),
        removeCssClass,
        addCssClass;

      if (cssClasses.contains(cssClassB)) {
        addCssClass = cssClassA;
        removeCssClass = cssClassB;
      }
      else {
        addCssClass = cssClassB;
        removeCssClass = cssClassA;
      }

      cssClasses.push(addCssClass);
      this._apply(
        HTMLElement.prototype.setAttribute, ['class',
          cssClasses.filter(isNotEqual(removeCssClass)).join(JSZ.BLANK)]
      );
    },

    /**
     * Adds an event listener of type click to the element.
     */
    onClick: function (fun, scope, config) {
      return jsz.Listener.add(this, 'click', fun, scope, config);
    },

    $: function(selectors) {
      return $(selectors, this);
    },

    $$: function(selectors) {
      return  $$(selectors, this);
    }

  });

  jsz.HTMLElement.build = function(element) {
    return new jsz.HTMLElement(element);
  };

  jsz.HTMLElement.make = function (tagName, attributes, content) {
    if ( arguments.length === 1) {
      attributes = {};
      content = JSZ.EMPTY_STRING;
    }
    else if ( arguments.length === 2) {
      if ( jsz.isString(attributes)) {
        content = attributes;
        attributes = {};
      }
    }

    var element = new jsz.HTMLElement( document.createElement(tagName));
    element.setAttributes(attributes);
    element.html(content);

    return element;
  };

  jsz.HTMLElement.get = function(htmlElement) {
    return htmlElement.get();
  };

  jsz.HTMLElement.empty = new jsz.HTMLElement();
});


script({
  name: 'lib.jsz.core.HTMLElementsList',
  require: [
    'lib.jsz.core.Namespace',
    'lib.jsz.core.jsz'
  ]
}, function () {
  'use strict';

  namespace('jsz').proto('HTMLElementsList', {

    HTMLElementsList: function (elements) {
      this._elements = jsz.default(elements, []);
    },

    _apply: function (fun, scope, args) {
      this._elements.forEach(function (element) {
        args.unshift(element);
        fun.apply(scope, args);
      });
    },

    map: function (fun, args) {
      this._elements.forEach(function (element) {
        fun.apply(element, args);
      });
    },

    get: function (index) {
      var result;

      if ( index === undefined) {
        result = this._elements;
      }
      else {
        result = this._elements[index];
      }
      return result;
    },

    setStyle: function (style, value) {
      this._apply(jsz.dom.setStyle, jsz.dom, [style, value]);
    },

    isEmpty: function () {
      return this._elements.isEmpty();
    },

    forEach: function (fun, scope) {
      this._elements.forEach(fun, scope);
    },

    indexOf: function (element, fromIndex) {
      return this._elements.indexOf(element, fromIndex);
    },

    /** Adds an event listener of type click to all elements.
     */
    onClick: function (fun, scope, config) {
      this.map(jsz.HTMLElement.prototype.onClick, [fun, scope, config]);
    },

    size: function() {
      return this._elements.length;
    }

  });

  jsz.HTMLElementsList.empty = new jsz.HTMLElementsList();

});


//TODO: Documentation
script({
  name: 'lib.jsz.core.dollar',
  require: [
    'lib.jsz.core.Array',
    'lib.jsz.core.HTMLElement',
    'lib.jsz.core.HTMLElementsList'
  ]
}, function () {
  'use strict';

  /**
   * Returns a reference to the element by its ID.
   *
   * @param {String} id
   * @returns {jsz.HTMLElement}
   */
  window.$id = function (id) {
    return new jsz.HTMLElement(document.getElementById(id));
  };

  /**
   * Returns a reference to to the first element that matches the given
   * selectors.
   *
   * @param {String} selectors is a group of selectors to match on.
   * @param {jsz.HTMLElement} [htmlElement=document] is the root element on
   *   which the query starts.
   * @returns {jsz.HTMLElement}
   */
  window.$ = function (selectors, htmlElement) {
    var result = jsz.HTMLElement.empty,
      root = null;

    if (htmlElement === undefined) {
      root = document;
    }
    else if (!htmlElement.isEmpty()) {
      root = htmlElement.get();
    }

    if (root !== null) {
      result = new jsz.HTMLElement(root.querySelector(selectors));
    }

    return result;
  };

  /**
   * Returns all reference to to the elements that matches the given
   * selectors.
   *
   * @param {String} selectors is a group of selectors to match on.
   * @param {jsz.HTMLElement} [htmlElement=document] is the root element on
   *   which the query starts.
   * @returns {jsz.HTMLElement}
   */
  window.$$ = function (selectors, htmlElement) {
    var result = jsz.HTMLElementsList.empty,
      root = null;

    if (htmlElement === undefined) {
      root = document;
    }
    else if (!(htmlElement instanceof jsz.HTMLElement)) {
      throw new Error('htmlElement must be of type jsz.HTMLElement!');
    }
    else if (htmlElement.isNotEmpty()){
      root = htmlElement.get();
    }

    if (root !== null) {
      result = new jsz.HTMLElementsList(
        Array.from(root.querySelectorAll(selectors))
          .map(jsz.HTMLElement.build));
    }

    return result;
  };

});

/**
 * Some tools for the Document Object Model.
 *
 * @author   Marcus Kruse
 * @version  0.1.0
 *
 */
script({
  name: 'lib.jsz.core.dom',
  require: [
    'lib.jsz.core.Namespace',
    'lib.jsz.core.String'
  ]
}, function () {
  'use strict';

  namespace('jsz').module('dom').def({

    /**
     * The function jsz.dom.setStyle sets a style attribute for an element. The
     * can be set by a key value pair or by an object.
     *
     * @example
     * // e.g. by key value pair
     * jsz.dom.setStyle(element, color, 'green');
     * // e.g. by object
     * jsz.dom.setStyle(element, {color:'green'});
     * 
     * @param {HTMLElement} element
     * @param {String} style
     * @param {Object} style
     * @param {String} [value]
     */
    setStyle: function (element, style, value) {
      if (style !== undefined) {
        if (value !== undefined) {
          // set style by key value pair
          return this._setStyle(element, style, value);
        }
        else {
          // set style by object
          Object.keys(style).forEach(function (key) {
            this._setStyle(element, key, style[key]);
          }, this);
        }
      }
    },

    /**
     * The function jsz.dom._setStyle sets a style attribute for an element.
     *
     * @param {HTMLElement} element
     * @param {String} style
     * @param {String} [value]
     *
     * @todo Test with IE10
     */
    _setStyle: function (element, style, value) {
      if (element) {

        if (typeof element.style === 'undefined') {
          log.error('element.style is undefined! Element: ' + element);
        }

        if (style === 'float') {
          style = 'cssFloat';
        }

        value = this._getStylesDefaultUnit(style, value);

        element.style[style.toCamelCase()] = value;
      } else {
        throw new Error('Can not set style! Element is undefined');
      }

      return element;
    },

    /**
     * The constant jsz.dom.STYLES_DEFAULT_UNIT holds default units for some css
     * attributes. This default will be used bj setStyle if the specified
     * attributes missing an unit.
     */
    STYLES_DEFAULT_UNIT: {
      height: 'em',
      width: 'em',
      top: 'em',
      left: 'em',
      padding: 'em',
      margin: 'em',
      paddingLeft: 'em',
      paddingRight: 'em'
    },

    /**
     * The function jsz.dom._getStyleDefaultUnit extends a value with a unit if
     * the unit is missing. The lookup table is hosted in
     * jsz.dom.STYLES_DEFAULT_UNIT.
     *
     * @param {String} style
     * @param {String} value
     * @returns {String}
     */
    _getStylesDefaultUnit: function (style, value) {
      var unit = this.STYLES_DEFAULT_UNIT[style],
        isNum = /^-?\d*$/.test(value);

      if (typeof unit !== undefined && isNum) {
        return value + unit;
      }

      return value;
    }

  });

});

/**
 * An own Error object for jsz. The class Error used the non-standard attribute
 * stack of the built-in Error object.
 *
 * @author   Marcus Kruse
 * @version  0.1.0
 *
 */
script({
  name: 'lib.jsz.core.Error',
  require: [
    'lib.jsz.core.Namespace',
    'lib.jsz.core.Object'
  ]
}, function() {
  'use strict';

  namespace('jsz').class( 'Error').def({

    /**
     * Create a new jsz.Error. A jsz.Error object has a stack attribute of type
     * array. The stack array contains objects called stack frames.
     *
     * @member {String} filePath
     * @member {String} fileName
     * @member {String} protocol
     * @member {String} host
     * @member {String} port
     * @member {String} path
     * @member {String} fileName
     * @member {Integer} lineNumber
     * @member {Integer} colNumber
     * @member {StackFrame[]} stack
     *
     * @typedef {Object} StackFrame
     * {String} StackFrame.filePath
     * {String} StackFrame.fileName
     * {String} StackFrame.protocol
     * {String} StackFrame.host
     * {String} StackFrame.port
     * {String} StackFrame.path
     * {String} StackFrame.fileName
     * {Integer} StackFrame.lineNumber
     * {Integer} StackFrame.colNumber
     *
     * @param {Error} value - An Error object.
     * @param {String} value - The error message.
     * @param {Integer} skip [some=0] stack frames.
     * @param {Error} [causedBy=null] - An error that is the cause of this
     *   error.
     * @param {jsz.Error} [causedBy=null] - An error that is the cause of this
     *   error.
     * @constructor
     */
    Error: function(value, skip, causedBy) {
      // check argument skip
      if (skip === undefined) {
        skip = 0;
        causedBy = null;
      }
      else if (jsz.isError(skip)) {
        causedBy = skip;
        skip = 0;
      }

      // check argument causedBy
      if (causedBy === undefined) {
        this.causedBy = null;
      }
      else {
        if (causedBy instanceof Error) {
          this.causedBy = new jsz.Error(causedBy);
        }
        else {
          this.causedBy = causedBy;
        }
      }

      // check argument value
      if ( value instanceof Error) {
        // the argument value is an Error
        var error = value;

        this.message = error.message;
        this.name = error.name;

        // setup the stack
        this._setStack(
          this._getStack(error, false, skip)
        );
      }
      else {
        // the argument value is a message;
        var message = value;
        if (message === undefined) {
          message = JSZ.EMPTY_STRING;
        }

        this.message = message;
        this.name = this._jsz_.className;

        // setup the stack
        this._setStack(
          this._getStack(new Error(), true, skip)
        );
      }
    },

    /**
     * Set this.stack an copies the first frame from the stack to this error.
     * @param {StackFrame[]} stack
     */
    _setStack: function( stack) {
      this.stack = stack;
      if ( !stack.isEmpty()) {
        var stackFrame = this.stack[0];
        this.protocol = stackFrame.protocol;
        this.host = stackFrame.host;
        this.port = stackFrame.port;
        this.path = stackFrame.path;
        this.fileName = stackFrame.fileName;
        this.lineNumber = stackFrame.lineNumber;
        this.colNumber = stackFrame.colNumber;
      }
    },

    /**
     * Get an array of stack frames from the Error.stack string.
     * @param {Error} error
     * @param {Boolean} jszError
     * @param {Integer} skip
     * @returns {StackFrame[]}
     */
    _getStack: function( error, jszError, skip) {
      var stack =  error
        .stack
        .split(JSZ.NEW_LINE);

      // Opera stack starts with 'Error\n'
      if ( stack[0] === 'Error') {
        stack.shift();
      }

      return this._skip(stack.map(this._parseStackEntry), jszError, skip);
    },

    /**
     * This method skips some stack frames to point to the right position in
     * the code.
     *
     * @param {StackFrame[]} stack
     * @param {Boolean} jszError indicates if the Error a new jsz.Error
     * @param {Integer} skip holds an integer to skip some additional frames.
     * @returns {StackFrame[]}
     */
    _skip: function(stack, jszError, skip) {
      if (jszError) {
        // skip all stack frames until reaching the frame related to this
        // object.
        while(stack.length > 0 && stack[0].functionName !== this.name) {
          stack.shift();
        }
        // skip two frames more to reach the frame they is related to the point
        // where jsz.Error was created.
        if (stack.length > 2) {
          stack = stack.slice(2);
        }
      }

      // skip the number of frames that was provided by the creation of
      // jsz.Error.
      if ( skip > 0 && skip < stack.length) {
        stack = stack.slice(skip);
      }

      return stack;
    },

    /**
     * The method _parseStackEntry parsed the stack string of the built-in
     * Error and generates a StackFrame.
     *
     * @param {String} entry
     * @returns {StackFrame}
     * @private
     */
    _parseStackEntry: function(entry) {
      var entryObject = {}, codePointer, funAtPos;

      // Get the function name and the code pointer. The format of the stack
      // differs from browser to browser.
      if ( (/^\s*at\s/).test(entry)) {
        // Opera
        funAtPos = (/^\s*at\s+(.*)\s*\((.*)\)/).exec(entry);
        if (funAtPos === null) {
          funAtPos = (/^\s*at(\s+)(.*)/).exec(entry);
        }
      }
      else {
        // FireFox, Safari
        funAtPos = (/(.*)@(.*)$/).exec(entry);
      }

      if (funAtPos === null) {
        // this entry holds just a code pointer
        entryObject.functionName = JSZ.EMPTY_STRING;
        codePointer = entry;
      }
      else {
        // split the function string in a path part and a name part.
        var funPathName = (/(.*)\.(.*)/).exec(funAtPos[1]);
        if (funPathName !== null) {
          entryObject.functionPath = funPathName[1].trim();
          entryObject.functionName = funPathName[2].trim();
        }
        else {
          entryObject.functionPath = JSZ.EMPTY_STRING;
          entryObject.functionName = funAtPos[1].trim();
        }

        codePointer = funAtPos[2];
      }

      // Split code pointer. The code pointer has usually the format:
      // protocol://host:port/path/fileName:lineNumber:colNumber
      //     |        |   |    |      |         |         |
      //     |        |   |    |      |         |         +-----------+---+
      //     |        |   |    |      |         +---------------+---+ |   |
      //     |        |   |    |      +--------------------+--+ |   | |   |
      //     |        |   |    +---------------------+----+|  | |   | |   |
      //     |        |   +---------------------+---+|    ||  | |   | |   |
      //     |        +-----------------+-----+ |   ||    ||  | |   | |   |
      //     +-----------------+--+     |     | |   ||    ||  | |   | |   |
      //                       |  |     |     | |   ||    ||  | |   | |   |
      var codePointerParts = (/(.*):\/\/([^:]*):(\d*)(.*)\/(.*):(\d*):(\d*)/)
        .exec(codePointer);

      if ( codePointerParts === null) {
        entryObject.fileName = codePointer;
        entryObject.protocol = JSZ.EMPTY_STRING;
        entryObject.host = JSZ.EMPTY_STRING;
        entryObject.port = JSZ.EMPTY_STRING;
        entryObject.path = JSZ.EMPTY_STRING;
        entryObject.fileName = JSZ.EMPTY_STRING;
        entryObject.lineNumber = JSZ.EMPTY_STRING;
        entryObject.colNumber = JSZ.EMPTY_STRING;
      }
      else {
        entryObject.codePointer = codePointerParts[0];
        entryObject.protocol = codePointerParts[1];
        entryObject.host = codePointerParts[2];
        entryObject.port = codePointerParts[3];
        entryObject.path = codePointerParts[4];
        entryObject.fileName = codePointerParts[5];
        entryObject.lineNumber = codePointerParts[6];
        entryObject.colNumber = codePointerParts[7];
      }

      return entryObject;
    },

    /**
     * The toString method returns a string representing the specified
     * jsz.Error object.
     *
     * @returns {string}
     */
    toString: function() {
      return this.name + ':' +
        this.fileName + ':' +
        this.lineNumber + ':' +
        this.message;
    }

  });

});

script({
  name: 'lib.jsz.core.Listener',
  require: [
    'lib.jsz.core.Array',
    'lib.jsz.core.Namespace',
    'lib.jsz.core.Object'
  ]
}, function () {
  'use strict';

  _jsz_.listeners = {};

  namespace('jsz').class('Listener').def({
    Listener: function (id, element, type, callback, config) {
      this.id = id;
      this._element = element;
      this._type = type; // the event type
      this._callback = callback;

      this._avoidPropagation = jsz.default(config.avoidPropagation, false);

      this._avoidDefault = jsz.default(config.avoidDefault, true);
      if (this._element.isType('FILE')) {
        // For the input element of type file its impossible to avoid
        // the default.
        this._avoidDefault = false;
      }


      this._capture = jsz.default(config.capture, false);

      // The returnType indicates the argument for the callback.
      this._returnType = jsz.default(config.returnType, 'listener');
      // possible values:
      var returnTypes = [
        'listener', // The listener that handled the event.
        'event', // The event-object
        'target', // The target-element of the event
        'element' // The element of the listener
        // TODO: implement posInElement, posInDocument, posInContent
        // 'posInElement', // The click-position in the element
        // 'posInDocument', // The click-position in the document
        // 'posInContent'// The click-position in the content
      ];
      // check
      if (!returnTypes.contains(this._returnType)) {
        throw new Error(
          'Not a valid returnType! returnType = ' + this._returnType);
      }
    },

    _avoidDefault: true,
    _avoidPropagation: false,

    activate: function () {
      jsz.Listener.activate(this.id);
    },

    deactivate: function () {
      jsz.Listener.deactivate(this.id);
    },

    fire: function (event) {
      if (this._avoidDefault) {
        event.preventDefault();
      }

      if (this._avoidPropagation) {
        event.stopPropagation();
      }

      this._callback(this._getReturnType(event));
    },

    _getReturnType: function (event) {
      var returnType = null;
      switch (this._returnType) {
        case 'listener':
          returnType = this;
          break;
        case 'event':
          returnType = event;
          break;
        case 'target':
          returnType = new jsz.HTMLElement(event.target);
          break;
        case 'element':
          returnType = this._element;
          break;
      }

      return returnType;
    }


  }).static({

    _handles: {},
    _ID_PREFIX: 'lsr:',
    _idCounter: 0,
    _listeners: {},
    _typeMap: {
      returnKey: 'keydown',
      escKey: 'keydown'
    },

    /**
     * The jsz.Listener.add methods registers a listener on an element.
     * @params
     *   element:[jsz.HTMLElement|String],
     *   type:['click'|...],
     *   fun:callback:Function,
     *   [ scope:jsz.Object,
     *     config:{returntype, ...}]
     * @returns listener:jsx.Listener
     */
    add: function (element, type, fun, scope, config) {
      var args = this._args4add(element, type, fun, scope, config);

      var id = this._newId();
      this._handles[id] = this._getHandleFunction(id);

      // Their are some more listener types as event types, so the event type
      // can differ from the listener type.
      // e.g.: listener type returnKey - event type keydown
      type = this._typeMap[args.type] || args.type;

      _jsz_.listeners[id] = new this(
        id, args.element, type, args.callback, args.config);


      if (args.config.active !== false) {
        this.activate(id);
      }

      return _jsz_.listeners[id];
    },

    activate: function (id) {
      var listener = _jsz_.listeners[id];
      var handle = this._handles[id];
      var element = listener._element.get();

      element.addEventListener(
        listener._type,
        handle,
        listener._capture
      );
    },

    deactivate: function (id) {
      var listener = _jsz_.listeners[id];
      var handle = this._handles[id];
      var element = listener._element.get();

      element.removeEventListener(
        listener._type,
        handle,
        listener._capture
      );
    },

    _args4add: function (element, type, fun, scope, config) {
      var object = {
        element: element,
        type: type,
        callback: fun,
        config: {}
      };

      if (scope instanceof jsz.Object || scope instanceof _jsz_.Namespace) {
        object.callback = unite(object.callback, scope);
        object.config = jsz.default(config, {});
      }
      else {
        // change argument scope to config
        object.config = jsz.default(scope, {});
      }

      if (typeof object.element === 'string') {
        object.element = $id(object.element);
      }

      if (object.element.isEmpty()) {
        throw new Error('Missing element for listener!');
      }

      // TODO: This part needs a refactoring when jsz.gui is reimplemented.
      if (jsz.gui && ( object.element instanceof jsz.gui.Object)) {
        log.warn(
          'TODO: This part needs a refactoring when jsz.gui is reimplemented.');
        object.element = object.element.element;
      }

      return Object.freeze(object);
    },

    _newId: function () {
      return this._ID_PREFIX + this._idCounter++;
    },

    _getHandleFunction: function (id) {
      return function (event) {
        _jsz_.listeners[id].fire(event);
      };
    }

  });

});

script({
  name: 'lib.jsz.core.time',
  require: [
    'lib.jsz.core.Namespace',
    'lib.jsz.core.Object',
    'lib.jsz.core.Date'
  ]
}, function () {
  'use strict';

  namespace('jsz').module('time').def({

    second: function() {
      return new jsz.time.Seconds(1);
    },

    seconds: function(seconds) {
      return new jsz.time.Seconds(seconds);
    }

  });

  namespace('jsz.time').class('Seconds').def({

    Seconds: function(seconds) {
      this._seconds = seconds;
    },

    millis: function() {
      return this._seconds * Date.MILLIS_PER_SECOND;
    }
  });

});


/**     _
 *     (_) _________
 *     | |/ _____  /
 *    _| |\__ \ / /_
 *  / _   ____//____|
 * | (_) | Just Another
 *  \___/  JS Framework
 *
 */

(function() {
  'use strict';

  script({
    name: 'lib.jsz.core',
    default: true,
    require: [
      'lib.jsz.config',               // Configuration data.
      'lib.jsz.core.script',          // The script loader.
      'lib.jsz.core.config',          // Configuration for the script load and
                                      // jsz.
      'lib.jsz.core.main',            // some global constants and functions
      'lib.jsz.core.Array',           // Extensions for the built-in Array
      'lib.jsz.core.String',          // Extensions for the built-in String
      'lib.jsz.core.Date',            // Extensions for the built-in Date
      'lib.jsz.core.Function',        // Extensions for the built-in Function
      'lib.jsz.core.JSON',            // Extensions for the built-in JSON
      'lib.jsz.core.Namespace',       // Namespace for classes, modules, ...
      'lib.jsz.core.jsz',             // The jsz-namespace.
      'lib.jsz.core.Object',          // jsz.Object and ext. for the built-in.
      'lib.jsz.core.HTMLElement',     // A wrapper for the HTMLElements.
      'lib.jsz.core.HTMLElementsList',// A wrapper for a list ofr HTMLElements.
      'lib.jsz.core.dollar',          // Functions: $, $id, $$, ...
      'lib.jsz.core.dom',             // Functions to manipulate the DOM.
      'lib.jsz.core.Error',           // The jsz.Error class.
      'lib.jsz.core.Listener',        // Listener: A wrapper for all events.
      'lib.jsz.core.time'             // Some tools to works with dates and time
    ]
  });
})();